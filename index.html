<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ® AI æ•¸å­¸å°å¤©æ‰ - ç®—å¼ç¯‡</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'Comic Sans MS', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden;
            padding: 10px;
        }

        .container {
            background: white;
            border-radius: 30px;
            padding: 25px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 700px;
            width: 100%;
            text-align: center;
        }

        h1 {
            color: #667eea;
            font-size: 2em;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #888;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        /* Stats */
        .stats {
            display: flex;
            justify-content: space-around;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 15px;
            padding: 12px;
            color: white;
            margin-bottom: 15px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.8em;
        }

        /* Progress */
        .progress-bar {
            background: #e0e0e0;
            border-radius: 10px;
            height: 12px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00d4ff);
            border-radius: 10px;
            transition: width 0.3s;
        }

        /* Question */
        .question-box {
            background: linear-gradient(135deg, #e8f4fd 0%, #d4e8f7 100%);
            border: 3px solid #667eea;
            border-radius: 20px;
            padding: 20px;
            margin: 15px 0;
            font-size: 1.2em;
            color: #333;
            line-height: 1.6;
        }

        /* Drag Elements */
        .elements-area {
            background: #f8f9fa;
            border: 3px dashed #ddd;
            border-radius: 15px;
            padding: 15px;
            margin: 15px 0;
        }

        .elements-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 10px;
        }

        .elements-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            min-height: 60px;
            padding: 10px;
            background: white;
            border-radius: 12px;
        }

        .drag-element {
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            font-size: 1.3em;
            font-weight: bold;
            cursor: grab;
            user-select: none;
            transition: all 0.2s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .drag-element:active {
            cursor: grabbing;
            transform: scale(0.95);
        }

        .drag-element.number {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        }

        .drag-element.operator {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
        }

        .drag-element.parenthesis {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
        }

        .drag-element.distractor {
            background: linear-gradient(135deg, #9e9e9e 0%, #757575 100%);
            opacity: 0.7;
        }

        .drag-element.used {
            opacity: 0.3;
            pointer-events: none;
        }

        /* Expression Workspace */
        .workspace-area {
            background: #fffde7;
            border: 3px solid #ffc107;
            border-radius: 15px;
            padding: 15px;
            margin: 15px 0;
            min-height: 120px;
        }

        .workspace-label {
            font-size: 0.85em;
            color: #ff8f00;
            margin-bottom: 10px;
        }

        .workspace {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            align-items: center;
            min-height: 80px;
            padding: 15px;
            background: white;
            border-radius: 12px;
        }

        .workspace-slot {
            width: 50px;
            height: 50px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f5f5f5;
        }

        .workspace-element {
            padding: 10px 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: grab;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .workspace-element .remove-btn {
            background: rgba(255,255,255,0.3);
            border: none;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 0.8em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .workspace-element .remove-btn:hover {
            background: rgba(255,255,255,0.5);
        }

        /* Buttons */
        .btn-row {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .btn {
            padding: 12px 25px;
            font-size: 1em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #607D8B 0%, #546E7A 100%);
            color: white;
        }

        /* Hint Area */
        .hint-area {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border: 2px solid #2196F3;
            border-radius: 12px;
            padding: 12px;
            margin: 10px 0;
            display: none;
        }

        .hint-area.show {
            display: block;
        }

        .hint-title {
            color: #1976D2;
            font-weight: bold;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .hint-content {
            color: #333;
            line-height: 1.6;
            font-size: 0.95em;
        }

        /* Start Screen */
        #startScreen {
            padding: 30px;
        }

        #gameScreen {
            display: none;
        }

        /* Result Animation */
        .result-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .result-overlay.show {
            display: flex;
        }

        .result-box {
            background: white;
            border-radius: 30px;
            padding: 40px;
            text-align: center;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .result-emoji {
            font-size: 4em;
            margin: 10px 0;
        }

        .result-score {
            font-size: 3em;
            color: #667eea;
            font-weight: bold;
        }

        /* Drop Zone Highlight */
        .workspace.drag-over {
            background: #fff9c4;
            border-color: #ffc107;
        }

        /* Instructions */
        .instructions {
            background: #fff3e0;
            border: 2px solid #ff9800;
            border-radius: 12px;
            padding: 12px;
            margin: 10px 0;
            font-size: 0.9em;
            color: #e65100;
        }

        /* Mobile Responsive */
        @media (max-width: 480px) {
            .container {
                padding: 15px;
                border-radius: 20px;
            }
            
            h1 {
                font-size: 1.6em;
            }
            
            .stats {
                padding: 10px;
            }
            
            .stat-value {
                font-size: 1.2em;
            }
            
            .question-box {
                font-size: 1em;
                padding: 15px;
            }
            
            .drag-element {
                padding: 10px 15px;
                font-size: 1.1em;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 0.9em;
            }
        }

        /* Prevent text selection */
        .drag-element, .workspace-element, .btn {
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        /* Prevent scrolling while dragging on mobile */
        .elements-container, .workspace {
            touch-action: none;
        }

        /* Mobile touch feedback */
        .drag-element:active, .workspace-element:active {
            transform: scale(0.95);
        }

        .drag-element.used {
            opacity: 0.3;
            pointer-events: none;
            filter: grayscale(50%);
        }

        /* Workspace drop zone highlight */
        .workspace.drag-over {
            background: #fff9c4;
            border-color: #ffc107;
            box-shadow: 0 0 20px rgba(255, 193, 7, 0.5);
        }

        /* Touch drag visual */
        .touch-dragging {
            position: fixed;
            z-index: 9999;
            pointer-events: none;
            opacity: 0.9;
            transform: scale(1.15);
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Start Screen -->
        <div id="startScreen">
            <h1>ğŸ® AI æ•¸å­¸å°å¤©æ‰</h1>
            <p class="subtitle">æ‹–æ›³æ•¸å­—åŒé‹ç®—ç¬¦è™Ÿï¼Œçµ„æˆæ­£ç¢ºæ—¢ç®—å¼ï¼</p>
            
            <div class="instructions">
                ğŸ“– <strong>é»ç©ï¼š</strong><br>
                1. ç‡æ¸…æ¥šé¡Œç›®<br>
                2. æ‹–æ›³æˆ–é»æ“Šå•±å•±æ•¸å­—åŒç¬¦è™Ÿ<br>
                3. çµ„æˆç®—å¼å¾ŒæŒ‰ã€Œâœ… ç¢ºèªã€<br>
                4. å””è­˜å¯ä»¥æŒ‰ã€ŒğŸ’¡ æç¤ºã€
            </div>
            
            <button class="btn btn-primary" id="startBtn" style="font-size: 1.2em; padding: 15px 40px;">
                ğŸš€ é–‹å§‹æŒ‘æˆ°
            </button>
        </div>

        <!-- Game Screen -->
        <div id="gameScreen">
            <h1>ğŸ® æ•¸å­¸å¤§å†’éšª</h1>
            <p class="subtitle">çµ„æˆæ­£ç¢ºæ—¢ç®—å¼ï¼</p>

            <!-- Stats -->
            <div class="stats">
                <div>
                    <div class="stat-value" id="score">0</div>
                    <div class="stat-label">åˆ†æ•¸</div>
                </div>
                <div>
                    <div class="stat-value" id="questionNum">1/10</div>
                    <div class="stat-label">é¡Œç›®</div>
                </div>
                <div>
                    <div class="stat-value" id="streak">0</div>
                    <div class="stat-label">é€£å‹</div>
                </div>
            </div>

            <!-- Progress -->
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>

            <!-- Question -->
            <div class="question-box" id="question">
                æº–å‚™å¥½æœªï¼Ÿ
            </div>

            <!-- Elements to Drag -->
            <div class="elements-area">
                <div class="elements-label">ğŸ“¦ æ‹–æ›³ä»¥ä¸‹å…ƒç´ å»çµ„æˆç®—å¼ï¼š</div>
                <div class="elements-container" id="elementsContainer">
                    <!-- Elements will be generated here -->
                </div>
            </div>

            <!-- Workspace -->
            <div class="workspace-area">
                <div class="workspace-label">ğŸ”§ å·¥ä½œå€ï¼ˆæ‹–æ›³æˆ–é»æ“Šå…ƒç´ è½å»ï¼‰ï¼š</div>
                <div class="workspace" id="workspace" ondrop="drop(event)" ondragover="allowDrop(event)" ondragleave="dragLeave(event)">
                    <span style="color: #999;" id="workspaceHint">æœªæœ‰ä»»ä½•å…ƒç´ </span>
                </div>
            </div>

            <!-- Hint Area -->
            <div class="hint-area" id="hintArea">
                <div class="hint-title">ğŸ’¡ æç¤º</div>
                <div class="hint-content" id="hintContent"></div>
            </div>

            <!-- Buttons -->
            <div class="btn-row">
                <button class="btn btn-success" onclick="checkExpression()" style="font-size: 1.1em; padding: 15px 35px;">
                    âœ… ç¢ºèªç®—å¼
                </button>
                <button class="btn btn-warning" onclick="showHint()">
                    ğŸ’¡ æç¤º
                </button>
                <button class="btn btn-secondary" onclick="clearWorkspace()">
                    ğŸ—‘ï¸ æ¸…ç©º
                </button>
            </div>
        </div>
    </div>

    <!-- Result Overlay -->
    <div class="result-overlay" id="resultOverlay">
        <div class="result-box">
            <div class="result-emoji" id="resultEmoji">ğŸ‰</div>
            <div class="result-score" id="resultScore">100</div>
            <p style="color: #666; margin: 10px 0;" id="resultText">å‹æªï¼</p>
            <button class="btn btn-primary" onclick="nextQuestion()">ä¸‹ä¸€é¡Œ â¡ï¸</button>
        </div>
    </div>

    <script>
        // ==================== CONFIG ====================
        const CONFIG = {
            totalQuestions: 10,
            pointsPerCorrect: 100,
            streakBonus: 20,
            maxStreak: 5
        };

        // ==================== STATE ====================
        let state = {
            score: 0,
            streak: 0,
            currentQuestion: 0,
            currentProblem: null,
            workspace: [],
            availableElements: [],
            gameActive: false
        };

        // ==================== PROBLEM GENERATOR ====================
        function generateProblem() {
            const types = ['add_2num', 'add_3num', 'sub', 'mul', 'time_morning', 'shopping_dozencake', 'mixed_2step'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            let problem = {};
            
            if (type === 'add_2num') {
                // ç°¡å–®åŠ æ³•
                const a = getRandom(15, 80);
                const b = getRandom(10, 50);
                const result = a + b;
                problem = {
                    type: 'add',
                    question: `å°æ˜æœ‰ ${a} ç²’ç³–ï¼Œåª½åª½å†æ¯” ${b} ç²’ä½¢ï¼Œç¸½å…±æœ‰å¹¾å¤šç²’ï¼Ÿ`,
                    correctExpression: `${a}+${b}`,
                    expectedResult: result,
                    hint: `æœ‰ ${a} ç²’ç³–ï¼Œå†åŠ  ${b} ç²’ï¼Œå³ä¿‚ ${a} + ${b}`,
                    elements: generateElements([a, b], null, '+'),
                    numbers: [a, b],
                    operator: '+'
                };
            } else if (type === 'add_3num') {
                // ä¸‰å€‹æ•¸åŠ æ³•
                const a = getRandom(20, 60);
                const b = getRandom(15, 40);
                const c = getRandom(10, 30);
                const result = a + b + c;
                problem = {
                    type: 'add_3num',
                    question: `åœ–æ›¸é¤¨æœ‰ ${a} æœ¬æ›¸ï¼Œç¬¬ä¸€æ—¥å€Ÿå’— ${b} æœ¬ï¼Œç¬¬äºŒæ—¥åˆå€Ÿå’— ${c} æœ¬ï¼Œç¸½å…±å€Ÿå’—å¹¾å¤šæœ¬ï¼Ÿ`,
                    correctExpression: `${a}+${b}+${c}`,
                    expectedResult: result,
                    hint: `ä¸‰å€‹æ•¸åŠ åŸ‹ï¼š${a} + ${b} + ${c}`,
                    elements: generateElements([a, b, c], null, '+'),
                    numbers: [a, b, c],
                    operator: '+'
                };
            } else if (type === 'sub') {
                // æ¸›æ³•
                const a = getRandom(50, 150);
                const b = getRandom(20, 60);
                const result = a - b;
                problem = {
                    type: 'sub',
                    question: `æœ‰ ${a} ç²’ç³–ï¼Œç”¨å’— ${b} ç²’ï¼Œä»²å‰©å¹¾å¤šç²’ï¼Ÿ`,
                    correctExpression: `${a}-${b}`,
                    expectedResult: result,
                    hint: `ç”± ${a} ç²’å…¥é¢æ‰£èµ° ${b} ç²’ï¼Œå³ä¿‚ ${a} - ${b}`,
                    elements: generateElements([a, b], null, '-'),
                    numbers: [a, b],
                    operator: '-'
                };
            } else if (type === 'mul') {
                // ä¹˜æ³•
                const a = getRandom(3, 12);
                const b = getRandom(4, 9);
                const result = a * b;
                problem = {
                    type: 'mul',
                    question: `æ¯ç›’æœ‰ ${a} æ”¯é‰›ç­†ï¼Œæœ‰ ${b} ç›’ï¼Œç¸½å…±æœ‰å¹¾å¤šæ”¯ï¼Ÿ`,
                    correctExpression: `${a}Ã—${b}`,
                    expectedResult: result,
                    hint: `${a} æ”¯ç­† ${b} ç›’ï¼Œå³ä¿‚ ${a} Ã— ${b}`,
                    elements: generateElements([a, b], null, 'Ã—'),
                    numbers: [a, b],
                    operator: 'Ã—'
                };
            } else if (type === 'time_morning') {
                // æ™‚é–“ç›¸é—œé¡Œç›® - æœæ—©/ä¸‹æ™
                const morning = getRandom(30, 90);
                const diff = getRandom(15, 40);
                // ä¸‹æ™æ¯”æœæ—©å°‘å’— diff
                const afternoon = morning - diff;
                const result = morning + afternoon;
                problem = {
                    type: 'time_add',
                    question: `å°æ˜æœæ—©è³£å’— ${morning} å€‹åŒ…ï¼Œä¸‹æ™è³£å’—æ¯”æœæ—©å°‘ ${diff} å€‹ï¼Œå…¨æ—¥å…±è³£å¹¾å¤šå€‹ï¼Ÿ`,
                    correctExpression: `${morning}+${morning}-${diff}`,
                    expectedResult: result,
                    hint: `æœæ—© ${morning} å€‹ï¼Œä¸‹æ™ ${morning}-${diff} = ${afternoon} å€‹`,
                    elements: generateElements([morning, afternoon, diff], ['+', '-'], null),
                    numbers: [morning, afternoon, diff],
                    operators: ['+', '-']
                };
            } else if (type === 'shopping_dozencake') {
                // è³¼ç‰©é¡Œç›® - è›‹ç³•
                const cake = getRandom(5, 20);
                const dozen = 12;
                const result = cake * dozen;
                problem = {
                    type: 'shopping_mul',
                    question: `ä¸€å€‹è›‹ç³•è³£ ${cake} å…ƒï¼Œè²·ä¸€æ‰“ï¼ˆ12å€‹ï¼‰è¦å¹¾å¤šéŒ¢ï¼Ÿ`,
                    correctExpression: `${cake}Ã—12`,
                    expectedResult: result,
                    hint: `ä¸€å€‹ ${cake} å…ƒï¼Œä¸€æ‰“æœ‰ 12 å€‹ï¼Œå³ä¿‚ ${cake} Ã— 12`,
                    elements: generateElements([cake, 12], null, 'Ã—'),
                    numbers: [cake, 12],
                    operator: 'Ã—'
                };
            } else if (type === 'mixed_2step') {
                // å…©æ­¥é‹ç®—
                const start = getRandom(50, 150);
                const add1 = getRandom(20, 60);
                const sub1 = getRandom(15, 50);
                const result = start + add1 - sub1;
                problem = {
                    type: 'mixed_2step',
                    question: `å°æ˜æœ‰ ${start} ç²’ç³–ï¼Œåª½åª½æ¯”å’— ${add1} ç²’ä½¢ï¼Œç„¶å¾Œç”¨å’— ${sub1} ç²’ï¼Œä»²å‰©å¹¾å¤šç²’ï¼Ÿ`,
                    correctExpression: `${start}+${add1}-${sub1}`,
                    expectedResult: result,
                    hint: `å…ˆåŠ  ${add1}ï¼Œå†æ¸› ${sub1}ï¼š${start} + ${add1} - ${sub1}`,
                    elements: generateElements([start, add1, sub1], ['+', '-'], null),
                    numbers: [start, add1, sub1],
                    operators: ['+', '-']
                };
            }
            
            return problem;
        }

        function generateElements(numbers, operators, singleOp) {
            const elements = [];
            
            // åŠ å…¥æ­£ç¢ºçš„æ•¸å­—
            numbers.forEach(n => {
                elements.push({ type: 'number', value: n, label: n.toString(), correct: true });
            });
            
            // åŠ å…¥æ­£ç¢ºçš„é‹ç®—ç¬¦è™Ÿ
            if (singleOp) {
                elements.push({ type: 'operator', value: singleOp, label: singleOp, correct: true });
            } else if (operators) {
                operators.forEach(op => {
                    elements.push({ type: 'operator', value: op, label: op, correct: true });
                });
            }
            
            // åŠ å…¥å¹²æ“¾é … - æ›´å¤šæ•¸å­—
            const distractorNumbers = [];
            while (distractorNumbers.length < 3) {
                const d = getRandom(10, 99);
                if (!numbers.includes(d)) {
                    distractorNumbers.push(d);
                }
            }
            distractorNumbers.forEach(n => {
                elements.push({ type: 'distractor', value: n, label: n.toString(), correct: false });
            });
            
            // åŠ å…¥å¹²æ“¾é … - éŒ¯èª¤é‹ç®—ç¬¦è™Ÿ
            const allOps = ['+', '-', 'Ã—', 'Ã·'];
            let correctOp = singleOp || (operators ? operators[0] : '+');
            const wrongOps = allOps.filter(o => o !== correctOp);
            wrongOps.slice(0, 2).forEach(op => {
                elements.push({ type: 'distractor', value: op, label: op, correct: false });
            });
            
            // åŠ å…¥æ‹¬è™Ÿ
            elements.push({ type: 'parenthesis', value: '(', label: '(', correct: false });
            elements.push({ type: 'parenthesis', value: ')', label: ')', correct: false });
            
            // æ´—ç‰Œ
            return elements.sort(() => Math.random() - 0.5);
        }

        function getRandom(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // ==================== GAME LOGIC ====================
        function startGame() {
            console.log('startGame called');
            state.score = 0;
            state.streak = 0;
            state.currentQuestion = 0;
            state.gameActive = true;
            
            console.log('Hiding startScreen, showing gameScreen');
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            console.log('Calling nextQuestion');
            nextQuestion();
        }

        function nextQuestion() {
            state.currentQuestion++;
            state.workspace = [];
            
            if (state.currentQuestion > CONFIG.totalQuestions) {
                showFinalResult();
                return;
            }
            
            // Generate new problem
            state.currentProblem = generateProblem();
            
            // Update UI
            document.getElementById('question').textContent = state.currentProblem.question;
            document.getElementById('score').textContent = state.score;
            document.getElementById('questionNum').textContent = `${state.currentQuestion}/${CONFIG.totalQuestions}`;
            document.getElementById('streak').textContent = state.streak;
            document.getElementById('progressFill').style.width = `${((state.currentQuestion-1)/CONFIG.totalQuestions)*100}%`;
            
            // Generate elements
            renderElements();
            renderWorkspace();
            
            // Hide hint
            document.getElementById('hintArea').classList.remove('show');
            
            // Hide result overlay
            document.getElementById('resultOverlay').classList.remove('show');
        }

        function renderElements() {
            const container = document.getElementById('elementsContainer');
            container.innerHTML = '';
            
            state.currentProblem.elements.forEach((el, index) => {
                const div = document.createElement('div');
                div.className = `drag-element ${el.type}`;
                div.draggable = true;
                div.dataset.value = el.value;
                div.dataset.label = el.label;
                div.dataset.index = index;
                div.textContent = el.label;
                
                div.ondragstart = dragStart;
                div.ontouchstart = touchStart;
                
                container.appendChild(div);
            });
        }

        function renderWorkspace() {
            const workspace = document.getElementById('workspace');
            
            if (state.workspace.length === 0) {
                workspace.innerHTML = '<span style="color: #999;" id="workspaceHint">æœªæœ‰ä»»ä½•å…ƒç´ </span>';
                return;
            }
            
            workspace.innerHTML = '';
            
            state.workspace.forEach((el, index) => {
                const div = document.createElement('div');
                div.className = 'workspace-element';
                div.draggable = true;
                div.dataset.workspaceIndex = index;
                div.innerHTML = `
                    <span>${el.label}</span>
                    <button class="remove-btn" onclick="removeFromWorkspace(${index})">Ã—</button>
                `;
                
                div.ondragstart = workspaceDragStart;
                div.ontouchstart = touchStart;
                
                workspace.appendChild(div);
            });
        }

        // ==================== DRAG AND DROP + TOUCH SUPPORT ====================
        let draggedElement = null;
        let touchClone = null;

        function dragStart(e) {
            draggedElement = {
                value: e.target.dataset.value,
                label: e.target.dataset.label,
                index: parseInt(e.target.dataset.index),
                from: 'elements'
            };
            e.target.style.opacity = '0.5';
        }

        function workspaceDragStart(e) {
            const index = parseInt(e.target.dataset.workspaceIndex);
            draggedElement = {
                value: state.workspace[index].value,
                label: state.workspace[index].label,
                index: index,
                from: 'workspace'
            };
        }

        // ==================== TOUCH SUPPORT FOR MOBILE ====================
        let touchOffsetX = 0, touchOffsetY = 0;

        function touchStart(e) {
            // Check if touching remove button
            if (e.target.classList.contains('remove-btn')) {
                e.preventDefault();
                const index = parseInt(e.target.parentElement.dataset.workspaceIndex);
                removeFromWorkspace(index);
                return;
            }
            
            const touch = e.touches[0];
            const target = e.target.closest('.drag-element') || e.target.closest('.workspace-element');
            if (!target) return;
            
            e.preventDefault();
            
            const isWorkspace = target.closest('#workspace') !== null;
            const rect = target.getBoundingClientRect();
            
            draggedElement = {
                value: target.dataset.value,
                label: target.dataset.label,
                index: target.dataset.index !== undefined ? parseInt(target.dataset.index) : 
                       target.dataset.workspaceIndex !== undefined ? parseInt(target.dataset.workspaceIndex) : 0,
                from: isWorkspace ? 'workspace' : 'elements'
            };
            
            // Calculate offset so finger doesn't cover element
            touchOffsetX = touch.clientX - rect.left;
            touchOffsetY = touch.clientY - rect.top;
            
            // Hide original temporarily
            target.style.opacity = '0.3';
            
            // Create visual clone for dragging
            touchClone = target.cloneNode(true);
            touchClone.style.position = 'fixed';
            touchClone.style.zIndex = '9999';
            touchClone.style.pointerEvents = 'none';
            touchClone.style.opacity = '0.9';
            touchClone.style.transform = 'scale(1.15)';
            touchClone.style.boxShadow = '0 15px 40px rgba(0,0,0,0.4)';
            touchClone.style.transition = 'transform 0.1s';
            document.body.appendChild(touchClone);
            
            updateTouchClonePosition(touch);
            
            // Highlight workspace
            document.getElementById('workspace').classList.add('drag-over');
            
            // Add move and end listeners
            document.addEventListener('touchmove', touchMove, { passive: false });
            document.addEventListener('touchend', touchEnd);
            document.addEventListener('touchcancel', touchEnd);
        }

        function touchMove(e) {
            if (!touchClone) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            updateTouchClonePosition(touch);
            
            // Check if over workspace
            const elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const workspace = elemBelow?.closest('#workspace');
            
            if (workspace) {
                document.getElementById('workspace').classList.add('drag-over');
            } else {
                document.getElementById('workspace').classList.remove('drag-over');
            }
        }

        function updateTouchClonePosition(touch) {
            if (!touchClone) return;
            // Position element above finger
            touchClone.style.left = (touch.clientX - touchOffsetX) + 'px';
            touchClone.style.top = (touch.clientY - touchOffsetY - 50) + 'px';
        }

        function touchEnd(e) {
            if (!touchClone) {
                cleanupTouch();
                return;
            }
            
            const touch = e.changedTouches[0];
            
            // Check what's under the finger
            const elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const workspace = elemBelow?.closest('#workspace');
            const elementTarget = elemBelow?.closest('.drag-element');
            
            // Quick tap: if tapped on element area but not dropping in workspace, add it
            if (elementTarget && !workspace) {
                handleTapAdd(elementTarget);
                cleanupTouch();
                return;
            }
            
            if (workspace) {
                // Drop in workspace
                handleDrop();
            }
            
            cleanupTouch();
        }

        // Tap to add (simpler for mobile)
        function handleTapAdd(target) {
            if (!draggedElement) return;
            
            const index = parseInt(target.dataset.index);
            const el = state.currentProblem.elements[index];
            
            if (el && !target.classList.contains('used')) {
                state.workspace.push({
                    value: el.value,
                    label: el.label
                });
                renderElements();
                renderWorkspace();
            }
        }

        function cleanupTouch() {
            if (touchClone) {
                touchClone.remove();
                touchClone = null;
            }
            draggedElement = null;
            
            document.getElementById('workspace').classList.remove('drag-over');
            
            // Remove listeners
            document.removeEventListener('touchmove', touchMove);
            document.removeEventListener('touchend', touchEnd);
            document.removeEventListener('touchcancel', touchEnd);
            
            // Refresh displays
            renderElements();
            renderWorkspace();
        }

        function handleDrop() {
            if (!draggedElement) return;
            
            if (draggedElement.from === 'elements') {
                state.workspace.push({
                    value: draggedElement.value,
                    label: draggedElement.label
                });
            } else if (draggedElement.from === 'workspace') {
                state.workspace.splice(draggedElement.index, 1);
                state.workspace.push({
                    value: draggedElement.value,
                    label: draggedElement.label
                });
            }
            
            renderWorkspace();
            renderElements();
            draggedElement = null;
        }

        function allowDrop(e) {
            e.preventDefault();
            document.getElementById('workspace').classList.add('drag-over');
        }

        function dragLeave(e) {
            document.getElementById('workspace').classList.remove('drag-over');
        }

        function drop(e) {
            e.preventDefault();
            document.getElementById('workspace').classList.remove('drag-over');
            
            if (!draggedElement) return;
            
            handleDrop();
        }

        function removeFromWorkspace(index) {
            const removed = state.workspace[index];
            
            // Remove from workspace
            state.workspace.splice(index, 1);
            
            // Unmark the original element
            const originalIndex = state.currentProblem.elements.findIndex(
                el => el.value == removed.value && el.label == removed.label && el.correct
            );
            
            if (originalIndex !== -1) {
                const elements = document.querySelectorAll('.drag-element');
                if (elements[originalIndex]) {
                    elements[originalIndex].classList.remove('used');
                    elements[originalIndex].draggable = true;
                }
            }
            
            renderWorkspace();
            renderElements();
        }

        function clearWorkspace() {
            state.workspace = [];
            renderWorkspace();
            renderElements();
        }

        // ==================== CHECK ANSWER ====================
        function checkExpression() {
            if (state.workspace.length === 0) {
                showHint();
                return;
            }
            
            // Build expression string
            const expression = state.workspace.map(el => el.value).join('');
            
            // Check if expression matches expected
            const expected = state.currentProblem.correctExpression;
            
            // Calculate result
            let userResult = null;
            try {
                // Convert Ã— to * for eval
                const evalExpr = expression.replace(/Ã—/g, '*').replace(/Ã·/g, '/');
                userResult = eval(evalExpr);
            } catch (e) {
                userResult = null;
            }
            
            const isCorrect = expression === expected || userResult === state.currentProblem.expectedResult;
            
            if (isCorrect) {
                // Correct!
                state.streak++;
                const bonus = Math.min(state.streak, CONFIG.maxStreak) * CONFIG.streakBonus;
                state.score += CONFIG.pointsPerCorrect + bonus;
                
                showResultOverlay(true);
            } else {
                // Wrong
                state.streak = 0;
                showResultOverlay(false);
            }
            
            updateUI();
        }

        function showResultOverlay(correct) {
            const overlay = document.getElementById('resultOverlay');
            const emoji = document.getElementById('resultEmoji');
            const score = document.getElementById('resultScore');
            const text = document.getElementById('resultText');
            
            if (correct) {
                emoji.textContent = 'ğŸ‰';
                score.textContent = `+${CONFIG.pointsPerCorrect + Math.min(state.streak, CONFIG.maxStreak) * CONFIG.streakBonus}`;
                text.textContent = 'ç­”å•±å–‡ï¼å‹æªï¼';
                text.style.color = '#4CAF50';
            } else {
                emoji.textContent = 'ğŸ˜…';
                score.textContent = 'å†è©¦é';
                text.textContent = `æ­£ç¢ºç®—å¼ä¿‚ï¼š${state.currentProblem.correctExpression} = ${state.currentProblem.expectedResult}`;
                text.style.color = '#ff9800';
            }
            
            overlay.classList.add('show');
        }

        function updateUI() {
            document.getElementById('score').textContent = state.score;
            document.getElementById('streak').textContent = state.streak;
        }

        // ==================== HINT ====================
        function showHint() {
            const hintArea = document.getElementById('hintArea');
            const hintContent = document.getElementById('hintContent');
            
            // Provide progressive hint
            let hint = state.currentProblem.hint;
            
            // If workspace has some elements, give more specific hint
            if (state.workspace.length > 0) {
                const currentExpr = state.workspace.map(el => el.label).join(' ');
                hint = `ä½ è€Œå®¶çµ„æˆæ—¢ç®—å¼ä¿‚ï¼šã€Œ${currentExpr}ã€<br><br>${state.currentProblem.hint}`;
            }
            
            hintContent.innerHTML = hint;
            hintArea.classList.add('show');
        }

        // ==================== FINAL RESULT ====================
        function showFinalResult() {
            state.gameActive = false;
            
            const accuracy = state.score / (CONFIG.totalQuestions * CONFIG.pointsPerCorrect) * 100;
            
            let emoji = '';
            let text = '';
            
            if (accuracy >= 90) {
                emoji = 'ğŸ†';
                text = 'è¶…ç´šæ•¸å­¸å¤©æ‰ï¼';
            } else if (accuracy >= 70) {
                emoji = 'ğŸŒŸ';
                text = 'å¥½çŠ€åˆ©ï¼';
            } else if (accuracy >= 50) {
                emoji = 'ğŸ’ª';
                text = 'å””éŒ¯å–ï¼';
            } else {
                emoji = 'ğŸ”¥';
                text = 'å†æ¥å†å²ï¼';
            }
            
            const overlay = document.getElementById('resultOverlay');
            overlay.innerHTML = `
                <div class="result-box">
                    <div class="result-emoji">${emoji}</div>
                    <div class="result-score">${state.score}</div>
                    <p style="font-size: 1.5em; margin: 10px 0;">${text}</p>
                    <p style="color: #666;">å®Œæˆæ›¬ 10 é¡Œå–‡ï¼</p>
                    <button class="btn btn-primary" style="margin-top: 20px;" onclick="location.reload()">
                        ğŸ”„ å†ç©ä¸€æ¬¡
                    </button>
                </div>
            `;
            overlay.classList.add('show');
        }

        // ==================== INIT ====================
        window.onload = () => {
            // Initialize any needed state
            document.getElementById('startBtn').addEventListener('click', startGame);
        };
    </script>
</body>
</html>
